/*
 * SibAccessNota_service.c
 *
 * Generated by nota-stubgen3.pl 3.0pre1
 *  Date: 24-5-2010 12:35:18
 *
 * Source: sib.xml
 *  Created: 24-5-2010 9:59:10
 *  Modified: 24-5-2010 9:59:10
 *  Accessed: 24-5-2010 12:34:38
 *
 * Stub adapter version 3.0
 *
 */


/* Stub header */
#include "SibAccessNota_service.h"
/* Internal platform specific header */
#include <stubgen/hin3_stubadapter_if.h>


/* Static array to send packets (of type _req, _cnf or _ind).
 * Size of an array is currently 2048, but can be optimize with
 * maximum size of packet len sent. */
#define STUB_SIBACCESSNOTASERVICE_SENDBUFFER_SIZE 2048

static uint8_t nota_send_buffer[STUB_SIBACCESSNOTASERVICE_SENDBUFFER_SIZE];

/* Prototypes for parser functions */
static skeleton_parser_function SibAccessNota_service_parse_signal_id( uint16_t function_id, uint16_t* param_count );
static int SibAccessNota_Join_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Insert_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Remove_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Update_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Query_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Subscribe_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Unsubscribe_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );
static int SibAccessNota_Leave_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count );

/* Parser function */
static skeleton_parser_function SibAccessNota_service_parse_signal_id( uint16_t function_id, uint16_t* param_count )
{
	switch( function_id )
	{
		case JOIN_REQ_SIGNAL_ID:
		{
			*param_count = JOIN_REQ_TOKEN_NUMBER;
			return SibAccessNota_Join_req_parse;
		}
		case INSERT_REQ_SIGNAL_ID:
		{
			*param_count = INSERT_REQ_TOKEN_NUMBER;
			return SibAccessNota_Insert_req_parse;
		}
		case REMOVE_REQ_SIGNAL_ID:
		{
			*param_count = REMOVE_REQ_TOKEN_NUMBER;
			return SibAccessNota_Remove_req_parse;
		}
		case UPDATE_REQ_SIGNAL_ID:
		{
			*param_count = UPDATE_REQ_TOKEN_NUMBER;
			return SibAccessNota_Update_req_parse;
		}
		case QUERY_REQ_SIGNAL_ID:
		{
			*param_count = QUERY_REQ_TOKEN_NUMBER;
			return SibAccessNota_Query_req_parse;
		}
		case SUBSCRIBE_REQ_SIGNAL_ID:
		{
			*param_count = SUBSCRIBE_REQ_TOKEN_NUMBER;
			return SibAccessNota_Subscribe_req_parse;
		}
		case UNSUBSCRIBE_REQ_SIGNAL_ID:
		{
			*param_count = UNSUBSCRIBE_REQ_TOKEN_NUMBER;
			return SibAccessNota_Unsubscribe_req_parse;
		}
		case LEAVE_REQ_SIGNAL_ID:
		{
			*param_count = LEAVE_REQ_TOKEN_NUMBER;
			return SibAccessNota_Leave_req_parse;
		}
		default:
			return NULL;
	}
}

int SibAccessNota_service_new_connection( struct context_pointer* context )
{
	/* call to platform support library */
	return nota_stub_add_new_connection( context, SibAccessNota_service_parse_signal_id, SibAccessNota_service_handler_error, SibAccessNota_service_handler_disconnected );
}


int SibAccessNota_service_remove_connection( struct context_pointer* context )
{
	/* call to platform support library */
	return nota_stub_remove_connection( context );
}


int SibAccessNota_Join_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status, uint8_t* credentials, uint16_t credentials_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = JOIN_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( credentials_len );
	packet_len += JOIN_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,credentials,credentials_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( credentials_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Insert_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status, uint8_t* bNodes, uint16_t bNodes_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = INSERT_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( bNodes_len );
	packet_len += INSERT_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,bNodes,bNodes_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( bNodes_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Remove_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = REMOVE_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += REMOVE_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Update_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status, uint8_t* bNodes, uint16_t bNodes_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = UPDATE_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( bNodes_len );
	packet_len += UPDATE_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,bNodes,bNodes_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( bNodes_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Query_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status, uint8_t* results, uint16_t results_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = QUERY_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( results_len );
	packet_len += QUERY_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,results,results_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( results_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Subscribe_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status, uint8_t* subscription_id, uint16_t subscription_id_len, uint8_t* results, uint16_t results_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = SUBSCRIBE_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( results_len );
	packet_len += SUBSCRIBE_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,subscription_id,subscription_id_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,results,results_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( results_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Unsubscribe_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = UNSUBSCRIBE_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += UNSUBSCRIBE_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Leave_cnf( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = LEAVE_CNF_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += LEAVE_CNF_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Subscription_ind( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, uint32_t seqnum, uint8_t* subscription_id, uint16_t subscription_id_len, uint8_t* new_results, uint16_t new_results_len, uint8_t* obsolete_results, uint16_t obsolete_results_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = SUBSCRIPTION_IND_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( new_results_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( obsolete_results_len );
	packet_len += SUBSCRIPTION_IND_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], seqnum );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,subscription_id,subscription_id_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,new_results,new_results_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( new_results_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,obsolete_results,obsolete_results_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( obsolete_results_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Unsubscribe_ind( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status, uint8_t* subscription_id, uint16_t subscription_id_len )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = UNSUBSCRIBE_IND_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	packet_len += UNSUBSCRIBE_IND_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,subscription_id,subscription_id_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( subscription_id_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


int SibAccessNota_Leave_ind( struct context_pointer* context, uint8_t* nodeid, uint16_t nodeid_len, uint8_t* spaceid, uint16_t spaceid_len, uint32_t msgnum, sibstatus_t status )
{
	int ret = 0;
	uint8_t* buf = 0;
	uint16_t id = LEAVE_IND_SIGNAL_ID;
	int packet_len = 3;
	int partial_packet_sent = 0;
	int added_bytes = 0;

	/* Calculate packet size */
	packet_len += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	packet_len += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	packet_len += LEAVE_IND_PACKET_LENGTH;

	buf = &nota_send_buffer[0];

	/* Signal id */
	buf[added_bytes++]=TOKEN_SIGNAL16;
	NOTA_STUB_PACK16( &buf[added_bytes], id );
	added_bytes += 2;

	/* Packaging the values of the parameters into the buffer */
	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,nodeid,nodeid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( nodeid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	partial_packet_sent = nota_stub_send_binary_data_token(context, ( char* )&buf[0], added_bytes,spaceid,spaceid_len);
	if ( partial_packet_sent > 0 )
	{
		 added_bytes = 0;
		 packet_len =  packet_len - partial_packet_sent;
	}
	else if(partial_packet_sent == 0)
	{
		 added_bytes += 1 + nota_stub_calculate_binary_token_length( spaceid_len );
	}
	else
	{
		 return partial_packet_sent;
	}

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], msgnum );
	added_bytes += 4;

	buf[added_bytes++] = TOKEN_UINT32_T;
	NOTA_STUB_PACK32( &buf[added_bytes], status );
	added_bytes += 4;

	/* Send the buffer via the active socket */
	if ( packet_len > 0 )
	{
		ret = nota_stub_send_message( context, ( char* )buf, packet_len );
	}

	return ret;
}


static int SibAccessNota_Join_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == JOIN_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[3].type == TOKEN_BDATA8 ) || ( tokens[3].type == TOKEN_BDATA16 ) || ( tokens[3].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Join_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, tokens[3].type == TOKEN_NULL ? NULL : tokens[3].data.bdata.ptr, tokens[3].type == TOKEN_NULL ? 0 : tokens[3].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Insert_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == INSERT_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[5].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Insert_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( encoding_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len, ( confirm_t )tokens[5].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Remove_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == REMOVE_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[5].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Remove_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( encoding_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len, ( confirm_t )tokens[5].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Update_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == UPDATE_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[5].type == TOKEN_BDATA8 ) || ( tokens[5].type == TOKEN_BDATA16 ) || ( tokens[5].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[6].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Update_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( encoding_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len, tokens[5].type == TOKEN_NULL ? NULL : tokens[5].data.bdata.ptr, tokens[5].type == TOKEN_NULL ? 0 : tokens[5].data.bdata.len, ( confirm_t )tokens[6].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Query_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == QUERY_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[5].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Query_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( query_format_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len, ( confirm_t )tokens[5].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Subscribe_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == SUBSCRIBE_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[3].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[4].type == TOKEN_BDATA8 ) || ( tokens[4].type == TOKEN_BDATA16 ) || ( tokens[4].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[5].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Subscribe_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, ( query_format_t )tokens[3].data.uint32_t, tokens[4].type == TOKEN_NULL ? NULL : tokens[4].data.bdata.ptr, tokens[4].type == TOKEN_NULL ? 0 : tokens[4].data.bdata.len, ( confirm_t )tokens[5].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Unsubscribe_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == UNSUBSCRIBE_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[3].type == TOKEN_BDATA8 ) || ( tokens[3].type == TOKEN_BDATA16 ) || ( tokens[3].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Unsubscribe_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t, tokens[3].type == TOKEN_NULL ? NULL : tokens[3].data.bdata.ptr, tokens[3].type == TOKEN_NULL ? 0 : tokens[3].data.bdata.len );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

static int SibAccessNota_Leave_req_parse( struct context_pointer* context, struct token* tokens, int tokens_count )
{
	int ret = 0;

	NOTA_STUB_ASSERT( tokens_count == LEAVE_REQ_TOKEN_NUMBER );

	/* Validate tokens */
	if ( !( ( tokens[0].type == TOKEN_BDATA8 ) || ( tokens[0].type == TOKEN_BDATA16 ) || ( tokens[0].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( !( ( tokens[1].type == TOKEN_BDATA8 ) || ( tokens[1].type == TOKEN_BDATA16 ) || ( tokens[1].type == TOKEN_NULL ) ) )
	{
		ret = -1;
		goto finishparsing;
	}
	if ( tokens[2].type != TOKEN_UINT32_T )
	{
		ret = -1;
		goto finishparsing;
	}

	/* Allocate memory for variables */

	/* Unpack values from the tokens into variables */
 
	/* Call user implemented process method */
	SibAccessNota_Leave_req_process( context, tokens[0].type == TOKEN_NULL ? NULL : tokens[0].data.bdata.ptr, tokens[0].type == TOKEN_NULL ? 0 : tokens[0].data.bdata.len, tokens[1].type == TOKEN_NULL ? NULL : tokens[1].data.bdata.ptr, tokens[1].type == TOKEN_NULL ? 0 : tokens[1].data.bdata.len, tokens[2].data.uint32_t );

	/* Postprocess release temporary allocated memory */

	/* Handle possible errors */
finishparsing:

	return ret;
}

